<script type="text/javascript">
    RED.nodes.registerType('rpc-method', {
        category: 'network',
        color: '#3FADB5',
        defaults: {
            name: { value: "" },
            server: { value: "", type: "rpc-server", required: true },
            methodName: { value: "", required: true },
            description: { value: "" },
            exposeSchema: { value: false },
            schema: { value: "" },
            validateSchema: { value: false }
        },
        inputs: 1,
        outputs: 2,
        outputLabels: ["request", "error"],
        icon: "function.svg",
        label: function() {
            return this.name || `method: ${this.methodName}`;
        },
        labelStyle: function() {
            return this.name ? "node_label_italic" : "";
        },
        oneditprepare: function() {
            const node = this;
            
            // Parse existing schema or create empty
            let schemaData = { properties: [] };
            if (node.schema) {
                try {
                    const parsed = JSON.parse(node.schema);
                    schemaData.properties = parseSchemaToEditor(parsed);
                } catch (e) {
                    // Invalid JSON, start fresh
                }
            }
            
            // Convert JSON Schema to editor format (recursive)
            function parseSchemaToEditor(schema) {
                const properties = [];
                if (schema.properties) {
                    for (const [key, value] of Object.entries(schema.properties)) {
                        const prop = {
                            name: key,
                            type: value.type || 'string',
                            required: schema.required?.includes(key) || false
                        };
                        
                        // Handle nested object
                        if (value.type === 'object' && value.properties) {
                            prop.properties = parseSchemaToEditor(value);
                        }
                        
                        // Handle array of objects
                        if (value.type === 'array' && value.items) {
                            if (value.items.type === 'object' && value.items.properties) {
                                prop.itemType = 'object';
                                prop.itemProperties = parseSchemaToEditor(value.items);
                            } else {
                                prop.itemType = value.items.type || 'string';
                            }
                        }
                        
                        properties.push(prop);
                    }
                }
                return properties;
            }
            
            // Build schema editor UI (recursive)
            function buildPropertyEditor(properties, container, level = 0) {
                container.empty();
                
                properties.forEach((prop, index) => {
                    const row = $('<div class="schema-property-row" style="margin-bottom:8px; margin-left:' + (level * 20) + 'px;"></div>');
                    const controls = $('<div style="display:flex; align-items:center; gap:8px;"></div>');
                    
                    // Name input
                    const nameInput = $('<input type="text" placeholder="name" style="width:120px; font-family:monospace;">')
                        .val(prop.name)
                        .on('change', function() {
                            properties[index].name = $(this).val();
                        });
                    
                    // Type select
                    const typeSelect = $('<select style="width:110px;"></select>')
                        .html('<option value="string">string</option><option value="number">number</option><option value="integer">integer</option><option value="boolean">boolean</option><option value="object">object</option><option value="array">array</option><option value="array-object">array[object]</option>')
                        .val(prop.type === 'array' && prop.itemType === 'object' ? 'array-object' : prop.type)
                        .on('change', function() {
                            const newType = $(this).val();
                            if (newType === 'array-object') {
                                properties[index].type = 'array';
                                properties[index].itemType = 'object';
                                properties[index].itemProperties = properties[index].itemProperties || [];
                            } else if (newType === 'array') {
                                properties[index].type = 'array';
                                properties[index].itemType = 'string';
                                delete properties[index].itemProperties;
                            } else if (newType === 'object') {
                                properties[index].type = 'object';
                                properties[index].properties = properties[index].properties || [];
                                delete properties[index].itemType;
                                delete properties[index].itemProperties;
                            } else {
                                properties[index].type = newType;
                                delete properties[index].properties;
                                delete properties[index].itemType;
                                delete properties[index].itemProperties;
                            }
                            rebuildSchemaEditor();
                        });
                    
                    // Required checkbox
                    const requiredCheck = $('<input type="checkbox" style="margin:0 4px;">')
                        .prop('checked', prop.required)
                        .on('change', function() {
                            properties[index].required = $(this).is(':checked');
                        });
                    const requiredLabel = $('<label style="margin:0;">required</label>');
                    
                    // Remove button
                    const removeBtn = $('<button type="button" style="padding:2px 8px;">✕</button>')
                        .on('click', function() {
                            properties.splice(index, 1);
                            rebuildSchemaEditor();
                        });
                    
                    controls.append(nameInput, typeSelect, requiredCheck, requiredLabel, removeBtn);
                    row.append(controls);
                    container.append(row);
                    
                    // Nested object properties
                    if (prop.type === 'object' && prop.properties) {
                        const nestedContainer = $('<div class="nested-properties" style="margin-left:20px; margin-top:4px; margin-bottom:8px; padding-left:8px; border-left:2px solid #ccc;"></div>');
                        buildPropertyEditor(prop.properties, nestedContainer, level + 1);
                        
                        const addNestedBtn = $('<button type="button" style="padding:2px 8px; margin-left:' + ((level + 1) * 20) + 'px; font-size:11px;">+ nested property</button>')
                            .on('click', function() {
                                prop.properties.push({ name: '', type: 'string', required: false });
                                rebuildSchemaEditor();
                            });
                        nestedContainer.append(addNestedBtn);
                        container.append(nestedContainer);
                    }
                    
                    // Array of objects
                    if (prop.type === 'array' && prop.itemType === 'object' && prop.itemProperties) {
                        const itemContainer = $('<div class="array-item-properties" style="margin-left:20px; margin-top:4px; margin-bottom:8px; padding-left:8px; border-left:2px solid #9cc;"></div>');
                        const itemLabel = $('<div style="font-size:11px; color:#666; margin-bottom:4px; margin-left:' + ((level + 1) * 20) + 'px;">Item properties:</div>');
                        itemContainer.append(itemLabel);
                        buildPropertyEditor(prop.itemProperties, itemContainer, level + 1);
                        
                        const addItemPropBtn = $('<button type="button" style="padding:2px 8px; margin-left:' + ((level + 1) * 20) + 'px; font-size:11px;">+ item property</button>')
                            .on('click', function() {
                                prop.itemProperties.push({ name: '', type: 'string', required: false });
                                rebuildSchemaEditor();
                            });
                        itemContainer.append(addItemPropBtn);
                        container.append(itemContainer);
                    }
                    
                    // Simple array (show item type selector)
                    if (prop.type === 'array' && prop.itemType !== 'object') {
                        const arrayTypeRow = $('<div style="margin-left:' + ((level + 1) * 20 + 20) + 'px; margin-top:4px; margin-bottom:8px; font-size:11px;"></div>');
                        const arrayTypeLabel = $('<span style="color:#666; margin-right:8px;">Items:</span>');
                        const arrayTypeSelect = $('<select style="width:90px; font-size:11px;"></select>')
                            .html('<option value="string">string</option><option value="number">number</option><option value="integer">integer</option><option value="boolean">boolean</option>')
                            .val(prop.itemType || 'string')
                            .on('change', function() {
                                properties[index].itemType = $(this).val();
                            });
                        arrayTypeRow.append(arrayTypeLabel, arrayTypeSelect);
                        container.append(arrayTypeRow);
                    }
                });
            }
            
            function rebuildSchemaEditor() {
                const container = $('#schema-properties');
                buildPropertyEditor(schemaData.properties, container, 0);
                
                // Add root level button
                const addRow = $('<div style="margin-top:8px;"></div>');
                const addBtn = $('<button type="button" style="padding:4px 12px;">+ Add Property</button>')
                    .on('click', function() {
                        schemaData.properties.push({ name: '', type: 'string', required: false });
                        rebuildSchemaEditor();
                    });
                addRow.append(addBtn);
                container.append(addRow);
            }
            
            rebuildSchemaEditor();
            
            const toggleSchema = function() {
                if ($('#node-input-validateSchema').is(':checked')) {
                    $('#schema-row').show();
                } else {
                    $('#schema-row').hide();
                }
            };
            
            $('#node-input-validateSchema').on('change', toggleSchema);
            toggleSchema();
            
            // Store schema data for save
            node._schemaData = schemaData;
        },
        oneditsave: function() {
            // Build JSON schema from visual editor (recursive)
            function buildJsonSchema(properties) {
                const schema = {
                    type: "object",
                    properties: {},
                    required: []
                };
                
                properties.forEach(prop => {
                    if (!prop.name) return;
                    
                    if (prop.type === 'object' && prop.properties) {
                        schema.properties[prop.name] = buildJsonSchema(prop.properties);
                    } else if (prop.type === 'array') {
                        if (prop.itemType === 'object' && prop.itemProperties) {
                            schema.properties[prop.name] = {
                                type: 'array',
                                items: buildJsonSchema(prop.itemProperties)
                            };
                        } else {
                            schema.properties[prop.name] = {
                                type: 'array',
                                items: { type: prop.itemType || 'string' }
                            };
                        }
                    } else {
                        schema.properties[prop.name] = { type: prop.type };
                    }
                    
                    if (prop.required) {
                        schema.required.push(prop.name);
                    }
                });
                
                if (schema.required.length === 0) {
                    delete schema.required;
                }
                
                return schema;
            }
            
            if (this._schemaData && this._schemaData.properties.length > 0) {
                const schema = buildJsonSchema(this._schemaData.properties);
                this.schema = JSON.stringify(schema);
            } else {
                this.schema = '';
            }
            
            delete this._schemaData;
        },
        oneditcancel: function() {
            delete this._schemaData;
        }
    });
</script>

<script type="text/html" data-template-name="rpc-method">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    
    <div class="form-row">
        <label for="node-input-server"><i class="fa fa-server"></i> RPC Server</label>
        <input type="text" id="node-input-server">
    </div>
    
    <div class="form-row">
        <label for="node-input-methodName"><i class="fa fa-code"></i> Method Name</label>
        <input type="text" id="node-input-methodName" placeholder="myMethod">
    </div>
    
    <div class="form-row">
        <label for="node-input-description"><i class="fa fa-info-circle"></i> Description</label>
        <input type="text" id="node-input-description" placeholder="Describe what this method does">
    </div>
    
    <div class="form-row">
        <label>&nbsp;</label>
        <input type="checkbox" id="node-input-exposeSchema" style="display:inline-block; width:auto; vertical-align:top;">
        <label for="node-input-exposeSchema" style="width:70%">Expose Schema (allow introspection via __rpc.describe)</label>
    </div>
    
    <div class="form-row">
        <label>&nbsp;</label>
        <input type="checkbox" id="node-input-validateSchema" style="display:inline-block; width:auto; vertical-align:top;">
        <label for="node-input-validateSchema" style="width:70%">Validate Schema</label>
    </div>
    
    <div class="form-row" id="schema-row" style="display:none;">
        <label for="node-input-schema" style="vertical-align:top;"><i class="fa fa-list-alt"></i> Properties</label>
        <div id="schema-properties" style="display:inline-block; width:70%; vertical-align:top;">
            <!-- Dynamic property editor will be inserted here -->
        </div>
        <div class="form-tips" style="margin-left:100px; margin-top:8px;">Define the expected parameters for this method</div>
    </div>
</script>

<script type="text/html" data-help-name="rpc-method">
    <p>Registers a method handler in an RPC server.</p>
    
    <h3>Configuration</h3>
    <dl class="message-properties">
        <dt>RPC Server <span class="property-type">rpc-server</span></dt>
        <dd>The RPC server node to register this method with</dd>
        
        <dt>Method Name <span class="property-type">string</span></dt>
        <dd>The name of the method to register</dd>
        
        <dt class="optional">Description <span class="property-type">string</span></dt>
        <dd>Description of what this method does. Visible via introspection if schema is exposed.</dd>
        
        <dt class="optional">Expose Schema <span class="property-type">boolean</span></dt>
        <dd>Allow clients to discover this method via <code>__rpc.describe</code> and <code>__rpc.describeAll</code></dd>
        
        <dt>Validate Schema <span class="property-type">boolean</span></dt>
        <dd>Enable parameter validation with JSON Schema</dd>
        
        <dt class="optional">Schema <span class="property-type">object</span></dt>
        <dd>JSON Schema (Draft 7) for validating method parameters. Requests with invalid parameters will be rejected with error code -32602.</dd>
    </dl>
    
    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">any</span></dt>
        <dd>The result to return to the caller</dd>
        
        <dt>rpc.id <span class="property-type">string</span></dt>
        <dd>Request ID (automatically passed through)</dd>
        
        <dt class="optional">error <span class="property-type">object</span></dt>
        <dd>Error to return to caller (will also output to error port)</dd>
    </dl>
    
    <h3>Outputs</h3>
    <ol class="node-ports">
        <li>Request
            <dl class="message-properties">
                <dt>payload <span class="property-type">object</span></dt>
                <dd>The method parameters from the RPC request</dd>
                
                <dt>rpc.method <span class="property-type">string</span></dt>
                <dd>The method name that was called</dd>
                
                <dt>rpc.id <span class="property-type">string</span></dt>
                <dd>Request ID to track the response</dd>
            </dl>
        </li>
        <li>Error
            <dl class="message-properties">
                <dt>error <span class="property-type">object</span></dt>
                <dd>Error object when processing fails</dd>
            </dl>
        </li>
    </ol>
    
    <h3>Details</h3>
    <p>This node registers a method in an RPC server. When the method is called:</p>
    <ol>
        <li>Parameters are sent to <strong>output 1</strong> (request port)</li>
        <li>Process them in your flow</li>
        <li>Send the result back to this node's <strong>input</strong></li>
        <li>If an error occurs, it will also be sent to <strong>output 2</strong> (error port)</li>
    </ol>
    
    <h3>Example Flow</h3>
    <pre>[RPC Method: "add"]
  ↓ (output 1)
[Function: a + b]
  ↓
[back to RPC Method input]
  → Response sent to caller
  
If error:
  ↓ (output 2)
[Error Handler]</pre>
</script>
